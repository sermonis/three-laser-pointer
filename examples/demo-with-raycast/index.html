<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <title>demo</title>
</head>
<body>
    <canvas id="canvas" style="width: 100%; height: 100%;"></canvas>

    <script src="./three.min.js"></script>
    <script src="./stats.min.js"></script>
    <script src="./OrbitControls.js"></script>

    <script src="../../dist/three-laser-pointer.min.js"></script>

    <script>
        'use strict';

        const canvas = document.getElementById("canvas");
        const camera = new THREE.PerspectiveCamera(75, canvas.width/canvas.height, 0.1, 1000);
        camera.position.set(0, 0, 4);

        const renderer = new THREE.WebGLRenderer({
            // alpha: true,
            canvas: canvas,
        });

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // https://stackoverflow.com/questions/29884485/threejs-canvas-size-based-on-container
        const resizeCanvasToDisplaySize = (force=false) => {
            let width = canvas.clientWidth;
            let height = canvas.clientHeight;

            // adjust displayBuffer size to match
            if (force || canvas.width != width || canvas.height != height) {
                // you must pass false here or three.js sadly fights the browser
                // console.log "resizing: #{canvas.width} #{canvas.height} -> #{width} #{height}"
                renderer.setSize(width, height, false);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
        };
        resizeCanvasToDisplaySize(true); // first time


        let data = (() => {
            let scene = new THREE.Scene();
            let material = new THREE.MeshPhongMaterial({
                color: 0x40a040,
                // wireframe: true,
                side: THREE.FrontSide,
                // side: THREE.BackSide,
                // side: THREE.DoubleSide,
            });

            //======== add light
            // https://github.com/mrdoob/three.js/blob/master/examples/webvr_cubes.html
            scene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) );
            const light = new THREE.DirectionalLight( 0xffffff );
            light.position.set( 1, 1, 1 ).normalize();
            scene.add( light );

            //======== add cubes
            let geomBox = new THREE.BoxGeometry( 1/2, 1/2, 1/2 );
            const gridLen = 2;
            console.log('#cubes:', gridLen * gridLen * gridLen);
            for (let x = 0; x < gridLen; x++) {
                for (let y = 0; y < gridLen; y++) {
                    for (let z = 0; z < gridLen; z++) {
                        let m = new THREE.Mesh( geomBox, material );
                        m.position.x = x+1;
                        m.position.y = y;
                        m.position.z = z;
                        scene.add(m);
                    }
                }
            }

            //======== add triangles
            // https://threejs.org/docs/#api/core/Geometry
            // https://threejs.org/docs/#api/core/Face3
            let geomTri = new THREE.Geometry();
            geomTri.vertices.push(
                new THREE.Vector3( -1/4,  1/4, 0 ),
                new THREE.Vector3( -1/4, -1/4, 0 ),
                new THREE.Vector3(  1/4, -1/4, 0 )
            );
            geomTri.faces.push( new THREE.Face3( 0, 1, 2 ) );
            geomTri.computeBoundingSphere();
            geomTri.computeFaceNormals();
            geomTri.computeVertexNormals();
            for (let i = 0; i < 3; i++) {
                let m = new THREE.Mesh( geomTri, material );
                m.position.set(1+i, -1, 0)
                scene.add(m);
            }

            //======== add a pointer line

            let line = new LaserPointer.Line(32);
            line.updatePointsRandomWalk(32);
            scene.add(line);

            let laser = new LaserPointer.Laser(0x00ff00);
            // laser.point(1.75, -0.25, 1.25); // testing
            scene.add(laser);

            return {
                scene: scene,
                pick: (mx, my) => {
                    return;
                    if (0) { // for gpu-picking a mesh
                        let mesh = mp.pickMesh(mx, my, camera);
                        if (mesh !== null) {
                            console.log(`uuid: ${mesh.uuid}`);
                            if (1) { // gpu-picking + raycast combo
                                let intersect = mp.raycast(mx, my, [mesh], camera);
                                if (intersect !== null) {
                                    // console.log('intersect:', intersect);
                                    console.log('intersect.point:', intersect.point);
                                    // console.log('intersect.face:', intersect.face);
                                }
                            }
                        } else {
                            console.log('no meshes');
                        }
                    }
                    if (1) { // for gpu-picking a point
                        let point = mp.pickPoint(mx, my, camera);
                        if (point !== null) {
                            // laser.setPointer(0.3, -0.4, -1.2, camera); // debug: push pointer ahead enough so it's seen
                            laser.setSource(0.3, -0.4, -0.2, camera);
                            laser.point(point.x, point.y, point.z);
                            laser.toggle(true);
                            if (0) { // evaluate the picked point with raycasting
                                let intersect = mp.raycast(mx, my, mp.list(), camera);
                                if (intersect !== null) {
                                    let diff = (new THREE.Vector3()).subVectors(intersect.point, point).length();
                                    console.log('diff:', diff);
                                }
                            }
                        } else {
                            console.log('no points');
                            // let posInf = mp.getPositionInfinity(mx, my, camera);
                            // console.log('posInf:', posInf);
                            laser.toggle(false);
                        }
                    }
                },
            };
        })();

        renderer.domElement.addEventListener('mousemove', (e) => {
            // https://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element/18053642#18053642
            let rect = canvas.getBoundingClientRect();
            let mx = e.clientX - rect.left;
            let my = e.clientY - rect.top;
            // console.log('mouse:', mx, my, canvas.width, canvas.height);
            data.pick(mx, my);
        });

        let render = () => {
            renderer.render(data.scene, camera);
        };

        let stats = new Stats();
        document.body.appendChild(stats.dom);

        let stop = false;
        setTimeout(() => { stop = true; }, 16*1000);
        let animate = () => {
            stats.update();
            resizeCanvasToDisplaySize();

            if (stop) {
                console.log('animate(): stopping');
                return;
            }
            requestAnimationFrame(animate);
            render();
        };
        animate();
    </script>
</body>
</html>
