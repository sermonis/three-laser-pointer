<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <title>demo</title>
</head>
<body>
    <canvas id="canvas" style="width: 100%; height: 100%;"></canvas>

    <script src="./three.min.js"></script>
    <script src="./stats.min.js"></script>
    <script src="./OrbitControls.js"></script>

    <!-- <script src="../../dist/three-laser-pointer.min.js"></script> -->
    <script src="../../lib/three-laser-pointer.js"></script>

    <script>
        'use strict';

        const canvas = document.getElementById("canvas");
        const camera = new THREE.PerspectiveCamera(75, canvas.width/canvas.height, 0.1, 1000);
        camera.position.set(0, 0, 4);

        const renderer = new THREE.WebGLRenderer({
            // alpha: true,
            canvas: canvas,
        });

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // https://stackoverflow.com/questions/29884485/threejs-canvas-size-based-on-container
        const resizeCanvasToDisplaySize = (force=false) => {
            let width = canvas.clientWidth;
            let height = canvas.clientHeight;

            // adjust displayBuffer size to match
            if (force || canvas.width != width || canvas.height != height) {
                // you must pass false here or three.js sadly fights the browser
                // console.log "resizing: #{canvas.width} #{canvas.height} -> #{width} #{height}"
                renderer.setSize(width, height, false);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
        };
        resizeCanvasToDisplaySize(true); // first time


        let data = (() => {
            let scene = new THREE.Scene();
            let material = new THREE.MeshPhongMaterial({
                color: 0xc0c0c0,
                // wireframe: true,
                side: THREE.FrontSide,
                // side: THREE.BackSide,
                // side: THREE.DoubleSide,
            });

            //======== add light
            // https://github.com/mrdoob/three.js/blob/master/examples/webvr_cubes.html
            scene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) );
            const light = new THREE.DirectionalLight( 0xffffff );
            light.position.set( 1, 1, 1 ).normalize();
            scene.add( light );

            //======== add walls
            let walls = new THREE.Mesh(
                new THREE.BoxGeometry( 8, 8, 8 ),
                new THREE.MeshPhongMaterial({
                    color: 0xc0e0c0,
                    // wireframe: true,
                    side: THREE.BackSide,
                }));
            walls.rotation.y = Math.PI / 4;
            scene.add(walls);

            //======== add cubes
            let geomBox = new THREE.BoxGeometry( 1/2, 1/2, 1/2 );
            const gridLen = 2;
            console.log('#cubes:', gridLen * gridLen * gridLen);
            for (let x = 0; x < gridLen; x++) {
                for (let y = 0; y < gridLen; y++) {
                    for (let z = 0; z < gridLen; z++) {
                        let m = new THREE.Mesh( geomBox, material );
                        m.position.x = x+1;
                        m.position.y = y;
                        m.position.z = z;
                        scene.add(m);
                    }
                }
            }

            //======== add triangles
            // https://threejs.org/docs/#api/core/Geometry
            // https://threejs.org/docs/#api/core/Face3
            let geomTri = new THREE.Geometry();
            geomTri.vertices.push(
                new THREE.Vector3( -1/4,  1/4, 0 ),
                new THREE.Vector3( -1/4, -1/4, 0 ),
                new THREE.Vector3(  1/4, -1/4, 0 )
            );
            geomTri.faces.push( new THREE.Face3( 0, 1, 2 ) );
            geomTri.computeBoundingSphere();
            geomTri.computeFaceNormals();
            geomTri.computeVertexNormals();
            for (let i = 0; i < 3; i++) {
                let m = new THREE.Mesh( geomTri, material );
                m.position.set(1+i, -1, 0)
                scene.add(m);
            }

            //======== add laser
            if (1) {
                let line = new LaserPointer.Line(32, 0x00ffff);
                line.updatePointsRandomWalk(32);
                scene.add(line);
            }

            let laser = new LaserPointer.Laser({
                color: 0xffffff
            });
            scene.add(laser);

            const meshes = [];
            scene.traverse((node) => {
                if (node instanceof THREE.Mesh) {
                    meshes.push(node);
                }
            });

            return {
                scene: scene,
                pick: (mx, my, cam) => {
                    let isect = laser.raycastFromCamera(
                        mx, my, canvas.width, canvas.height, cam, meshes);
                    if (isect !== null) {
                        console.log('isect:', isect);
                        let pt = isect.point;
                        laser.setSource(new THREE.Vector3(0.3, -0.4, -0.2), cam);

                        // laser.point(pt, 0xff0000);
                        //----
                        laser.pointWithRaytrace(pt, meshes, 0xff0000);
                    } else {
                        console.log('no isects');
                        laser.clearPoints();
                    }
                    console.log('laser points:', laser.getPoints());
                },
            };
        })();

        const eventDrivenRender = 1;
        let stats = new Stats();
        document.body.appendChild(stats.dom);
        let render = () => {
            stats.update();
            resizeCanvasToDisplaySize();
            renderer.render(data.scene, camera);
        };

        renderer.domElement.addEventListener('mousemove', (e) => {
            // https://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element/18053642#18053642
            let rect = canvas.getBoundingClientRect();
            let mx = e.clientX - rect.left;
            let my = e.clientY - rect.top;
            // console.log('mouse:', mx, my, canvas.width, canvas.height);
            data.pick(mx, my, camera);
            if (eventDrivenRender) {
                render();
            }
        });

        if (eventDrivenRender) {
            render(); // first time
            controls.addEventListener('change', render);
        } else {
            let stop = false;
            setTimeout(() => { stop = true; }, 5*60*1000);
            let animate = () => {
                if (stop) {
                    console.log('animate(): stopping');
                    return;
                }
                requestAnimationFrame(animate);
                render();
            };
            animate();
        }
    </script>
</body>
</html>
